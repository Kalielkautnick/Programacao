/////////////////////////////////////////////////////////////////////////////////////
ESSE MERGE INTO FAZ O SEGUINTE, SE EXISTE DUAS OU MAIS VEZES O MESMO CÓDIGO, COR E TAMANHO NO MESMO PEDIDO,
PORÉM, AS QUANTIDADES E PREÇOS SÃO DIFERENTES E O VALOR TOTAL POR PRODUTO ESTÁ CERTO, O NOSSO OBJETIVO AQUI
É AGRUPAR AS QUANTIDADES E COLOCAR UM PREÇO DE TAL FORMA QUE CONTINUE DANDO O MESMO VALOR POR PRODUTO.

ENTÃO:
- O MERGE INTO VAI ALTERAR APENAS OS REGISTROS DUPLICADOS; 
- IRÁ AGRUPAR A QUANTIDADE E QUANTIDADE FATURADA;
- CONSIDERANDO QUE O VALOR TOTAL DAQUELE PRODUTO ESTEJA CERTO, ELE IRÁ CALCULAR O PREÇO CORRETO PARA QUE
QUANDO O SISTEMA CALCULE: QTDE * PREÇO, DÊ O MESMO VALOR;
- SE O ITEM ESTIVER APENAS DUPLICADO E DANDO 2X O VALOR CORRETO, PULE O MERGE INTO E VÁ PARA O DELETE;
/////////////////////////////////////////////////////////////////////////////////////

MERGE INTO PED_ITEN_001 PED_ERRADO 
USING (
SELECT NUMERO, CODIGO, COR, TAM, QTDE,
CAST((SELECT SUM((P.QTDE + P.QTDE_F) * CAST(PRECO AS NUMERIC(18,4))) FROM PED_ITEN_001 P  
WHERE P.NUMERO=TAB.NUMERO
AND P.CODIGO=TAB.CODIGO
AND P.COR=TAB.COR 
AND P.TAM=TAB.TAM) / (QTDE + QTDE_F) AS NUMERIC(18,4)) AS PRECO_CERTO FROM (
SELECT NUMERO, CODIGO, COR, TAM, SUM(QTDE) AS QTDE, SUM(QTDE_F) AS QTDE_F
FROM PED_ITEN_001 PED 
WHERE 1=1
AND NUMERO IN ('XXXXX')
AND EXISTS (
SELECT P.NUMERO, P.CODIGO, P.COR, P.TAM, COUNT(*) 
FROM PED_ITEN_001 P 
WHERE P.NUMERO=PED.NUMERO AND P.CODIGO=PED.CODIGO AND P.COR=PED.COR AND P.TAM=PED.TAM 
GROUP BY P.NUMERO, P.CODIGO, P.COR, P.TAM HAVING COUNT(*) > 1)
GROUP BY NUMERO, CODIGO, COR, TAM
ORDER BY NUMERO, CODIGO, COR, TAM) TAB) PED_CERTO
ON ((PED_CERTO.NUMERO=PED_ERRADO.NUMERO AND PED_CERTO.CODIGO=PED_ERRADO.CODIGO AND PED_CERTO.COR=PED_ERRADO.COR AND PED_CERTO.TAM=PED_ERRADO.TAM))
WHEN MATCHED THEN 
UPD-ATE SET PED_ERRADO.QTDE=PED_CERTO.QTDE, PED_ERRADO.QTDE_F=PED_CERTO.QTDE_F, PED_ERRADO.PRECO=PED_CERTO.PRECO_CERTO



OBS: APÓS ESSE UPDATE, AMBOS OS REGISTROS DUPLICADOS SERÃO ALTERADOS, ENTÃO EM SEGUIDA É NECESSÁRIO RODAR O DELETE.
----------------------------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////////////
EXCLUI O REGISTRO DUPLICADO ATRAVÉS DO CAMPO ORDEM, DELETA O QUE TIVER MENOR ORDEM,
ELE SÓ É GIGANTE ASSIM PORQUE PODE HAVER CASOS TRIPLICADOS OU MAIS.
/////////////////////////////////////////////////////////////////////////////////////

DEL-ETE FROM PED_ITEN_001 PEDIDO
WHERE EXISTS (
SELECT * FROM (
SELECT NUMERO, CODIGO, COR, TAM
FROM PED_ITEN_001 PED 
WHERE 1=1
--- OPCIONAL FILTRAR O NÚMERO
---AND NUMERO IN ('XXXXX')
AND EXISTS (
SELECT P.NUMERO, P.CODIGO, P.COR, P.TAM, COUNT(*) 
FROM PED_ITEN_001 P
WHERE P.NUMERO=PED.NUMERO AND P.CODIGO=PED.CODIGO AND P.COR=PED.COR AND P.TAM=PED.TAM
GROUP BY P.NUMERO, P.CODIGO, P.COR, P.TAM HAVING COUNT(*) > 2)
GROUP BY NUMERO, CODIGO, COR, TAM) TAB
WHERE TAB.NUMERO=PEDIDO.NUMERO
AND TAB.CODIGO=PEDIDO.CODIGO
AND TAB.COR=PEDIDO.COR
AND TAB.TAM=PEDIDO.TAM)
--- IRÁ TRAZER E REMOVER TODOS QUE NÃO FOREM IGUAIS AO ID MAIOR DAQUELE NUMERO, CÓDIGO, COR E TAMANHO.
AND NOT EXISTS (
SELECT * FROM (
SELECT NUMERO, CODIGO, COR, TAM, MAX(ID_ITEM_PED) ID_ITEM_PED
FROM PED_ITEN_001 PED 
WHERE 1=1
--- OPCIONAL FILTRAR O NÚMERO
---AND NUMERO IN ('XXXXX')
AND EXISTS (
SELECT P.NUMERO, P.CODIGO, P.COR, P.TAM, COUNT(*) 
FROM PED_ITEN_001 P
WHERE P.NUMERO=PED.NUMERO AND P.CODIGO=PED.CODIGO AND P.COR=PED.COR AND P.TAM=PED.TAM
GROUP BY P.NUMERO, P.CODIGO, P.COR, P.TAM HAVING COUNT(*) > 2)
GROUP BY NUMERO, CODIGO, COR, TAM) TAB
WHERE TAB.NUMERO=PEDIDO.NUMERO
AND TAB.CODIGO=PEDIDO.CODIGO
AND TAB.COR=PEDIDO.COR
AND TAB.TAM=PEDIDO.TAM
AND TAB.ID_ITEM_PED=PEDIDO.ID_ITEM_PED)